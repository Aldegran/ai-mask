<!DOCTYPE html>
<html>
    <body style="background: #000; color: #fff; text-align: center; font-family: monospace;">
        <h1>Low Latency Preview</h1>
        <div style="display: flex; flex-direction: column; align-items: center; gap: 20px;">
            <!-- Frame border controlled by JS via class/style -->
            <div id="videoContainer" style="border: 5px solid #444; padding: 2px;">
                <img id="videoStream" style="max-width: 100%; min-width: 640px; min-height: 480px; background: #222;" />
            </div>
            
            <div style="display: flex; gap: 20px; align-items: center;">
                <button id="startAudioBtn" style="padding: 10px 20px; font-size: 16px; cursor: pointer;">START MONITOR (Audio+Video)</button>
                
                <label style="display: flex; align-items: center; gap: 10px; font-size: 18px; cursor: pointer; user-select: none;">
                    <input type="checkbox" id="useGeminiCk" style="width: 20px; height: 20px;">
                    USE GEMINI AI
                </label>
            </div>

            <div id="status" style="color: #888;">System Status: Idle</div>

            <div style="width: 80%; max-width: 800px; text-align: left;">
                <label>Gemini Response Log:</label>
                <textarea id="geminiLog" readonly style="width: 100%; height: 200px; background: #111; color: #0f0; border: 1px solid #444; padding: 10px; font-family: monospace; font-size: 14px; margin-top: 5px;"></textarea>
            </div>
        </div>

        <script>
            const startBtn = document.getElementById('startAudioBtn');
            const useGeminiCk = document.getElementById('useGeminiCk');
            const statusDiv = document.getElementById('status');
            const videoImg = document.getElementById('videoStream');
            const videoContainer = document.getElementById('videoContainer');
            const geminiLog = document.getElementById('geminiLog');

            let audioCtx;
            let videoSocket;
            let audioSocket;
            let geminiControlSocket;
            let nextTime = 0;

            function log(msg) {
                geminiLog.value = `[${new Date().toLocaleTimeString()}] ${msg}\n` + geminiLog.value;
            }

            // --- GEMINI CONTROL ---
            function toggleGemini(enabled) {
                if (!geminiControlSocket || geminiControlSocket.readyState !== WebSocket.OPEN) return;
                
                geminiControlSocket.send(JSON.stringify({ 
                    type: 'gemini_control', 
                    enabled: enabled 
                }));

                if (enabled) {
                    videoContainer.style.borderColor = "#f00"; // Red Frame
                    log("Gemini Session REQUESTED...");
                } else {
                    videoContainer.style.borderColor = "#444"; // Grey Frame
                    log("Gemini Session ENDED.");
                }
            }

            useGeminiCk.addEventListener('change', (e) => {
                toggleGemini(e.target.checked);
            });

            // --- MONITOR SETUP ---
            function setupControlSocket() {
                const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                geminiControlSocket = new WebSocket(protocol + '//' + window.location.host + '/control');
                
                geminiControlSocket.onopen = () => console.log("Control WS Connected");
                geminiControlSocket.onmessage = (event) => {
                    const msg = JSON.parse(event.data);
                    if (msg.type === 'gemini_response') {
                        log("AI: " + msg.text);
                    }
                    if (msg.type === 'log') {
                        // System logs from server
                        // log("SYS: " + msg.text); 
                    }
                };
            }

            startBtn.onclick = async () => {
                startBtn.disabled = true;
                startBtn.innerText = "Connecting...";
                
                try {
                    // 1. Audio Context
                    audioCtx = new (window.AudioContext || window.webkitAudioContext)({
                        sampleRate: 16000, 
                        latencyHint: 'interactive'
                    });
                    await audioCtx.resume();

                    // 2. Control Socket
                    setupControlSocket();

                    // 3. Video Monitor
                    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                    videoSocket = new WebSocket(protocol + '//' + window.location.host + '/monitor/video');
                    videoSocket.binaryType = 'arraybuffer';
                    videoSocket.onmessage = (event) => {
                        const blob = new Blob([event.data], { type: 'image/jpeg' });
                        const url = URL.createObjectURL(blob);
                        videoImg.onload = () => URL.revokeObjectURL(url);
                        videoImg.src = url;
                    };

                    // 4. Audio Monitor (Expects Int16 now, need to fix playing)
                    // Since we switched server to s16le, we need to convert to float for AudioContext
                    audioSocket = new WebSocket(protocol + '//' + window.location.host + '/monitor/audio');
                    audioSocket.binaryType = 'arraybuffer';
                    
                    audioSocket.onmessage = (event) => {
                        if (audioCtx.state === 'suspended') audioCtx.resume();
                        
                        const rawData = new Int16Array(event.data); // Server sends s16le
                        const floatArray = new Float32Array(rawData.length);
                        
                        // Convert Int16 to Float32
                        for(let i=0; i<rawData.length; i++) {
                            floatArray[i] = rawData[i] / 32768.0;
                        }

                        const buffer = audioCtx.createBuffer(1, floatArray.length, 16000);
                        buffer.copyToChannel(floatArray, 0);
                        
                        const source = audioCtx.createBufferSource();
                        source.buffer = buffer;
                        source.connect(audioCtx.destination);
                        
                        if (nextTime < audioCtx.currentTime) nextTime = audioCtx.currentTime;
                        source.start(nextTime);
                        nextTime += buffer.duration;
                    };

                    statusDiv.innerText = "System Active. Ready to use Gemini.";
                    statusDiv.style.color = "#0f0";
                    startBtn.style.display = 'none';

                } catch (err) {
                    console.error(err);
                    statusDiv.innerText = "Error: " + err.message;
                    startBtn.disabled = false;
                }
            };
        </script>
    </body>
</html>