<!DOCTYPE html>
<html>
    <body style="background: #000; color: #fff; text-align: center; font-family: monospace;">
        <div style="display: flex; flex-direction: row; gap: 20px; padding: 20px; height: 90vh; align-items: flex-start;">
            
            <!-- LEFT COLUMN: Instruction -->
            <div style="flex: 1; display: flex; flex-direction: column; gap: 10px; justify-content: space-between; text-align: left; height: 100%;">
                
                <div style="display: flex; margin-top: 20px;">
                    <div>
                        <textarea id="behaviourArea" style="flex: 1; width: 214px; background: #0a0a0a; color: #ddd; border: 1px solid #333; padding: 5px; font-family: monospace; font-size: 14px; resize: none; border-radius: 5px; height: 435px;"></textarea>

                        <button id="saveBehBtn" style="padding: 15px; cursor: pointer; background: #222; color: #888; border: 1px solid #444; border-radius: 5px; font-weight: bold; transition: 0.2s;">SAVE BEHAIVIOR TO SERVER</button>

                        <!--textarea id="instructionArea" style="flex: 1; width: 100%; background: #0a0a0a; color: #ddd; border: 1px solid #333; padding: 15px; font-family: monospace; font-size: 14px; resize: none; border-radius: 5px;"></textarea>
                        
                        <button id="saveInstrBtn" style="padding: 15px; cursor: pointer; background: #222; color: #888; border: 1px solid #444; border-radius: 5px; font-weight: bold; transition: 0.2s;">SAVE INSTRUCTION TO SERVER</button-->
                    </div>
                    <div id="videoContainer" style="position: relative; border: 5px solid #444; padding: 2px; width: max-content; align-self: center;">
                        <img id="videoStream" style="width: 640px; min-height: 480px; background: #222;" />
                        <div id="emotionDisplay" style="position: absolute; bottom: 10px; right: 10px; font-size: 32px; font-weight: bold; color: #fff; text-shadow: 0 0 5px #000, 0 0 10px #f00;"></div>
                    </div>
                </div>
                <div style="display: flex; gap: 20px; align-items: center; background: #111; padding: 15px; border-radius: 10px; border: 1px solid #333;">
                    <button id="startAudioBtn" style="padding: 10px 20px; font-size: 16px; cursor: pointer; background: #004400; color: #fff; border: none; border-radius: 4px;">START MONITOR</button>
                    
                    <label style="display: flex; align-items: center; gap: 10px; font-size: 18px; cursor: pointer; user-select: none;">
                        <input type="checkbox" id="useGeminiCk" style="width: 20px; height: 20px;">
                        USE GEMINI AI
                    </label>

                    <label id="operatorSoundContainer" style="align-items: center; gap: 10px; font-size: 18px; cursor: pointer; user-select: none;">
                        <input type="checkbox" id="operatorMode" style="width: 20px; height: 20px;" />
                        OPERATOR SOUND
                    </label>
                    <label style="display: flex; align-items: center; gap: 10px; font-size: 18px; cursor: pointer; user-select: none;">
                        <input type="checkbox" id="sendAudioCk" checked style="width: 20px; height: 20px;">
                        SEND AUDIO
                    </label>
                    <label id="muteMicContainer" style="display: none; align-items: center; gap: 10px; font-size: 18px; cursor: pointer; user-select: none;">
                        <input type="checkbox" id="muteMicCk" style="width: 20px; height: 20px;" checked>
                        MUTE MIC ECHO
                    </label>
                </div>
            
                <!-- SOX TESTER -->
                <div style="display: flex; gap: 10px; align-items: center; background: #111; padding: 15px; border-radius: 10px; border: 1px solid #333; margin-top: 10px;">
                    <span style="font-weight: bold; color: #aaa;">VOICE TESTER:</span>
                    <input id="soxParamsInput" type="text" value="pitch -300 speed [s] echo 0.8 0.8 60 0.4" placeholder="SoX Params" style="flex: 1; min-width: 0; background: #0a0a0a; color: #ddd; border: 1px solid #333; padding: 8px; border-radius: 4px; font-family: monospace;">
                    <button id="testSoxBtn" style="padding: 8px 15px; cursor: pointer; background: #444; color: #fff; border: none; border-radius: 4px; font-weight: bold; white-space: nowrap;">TEST AUDIO</button>
                    <audio id="testAudioPlayer" controls style="height: 30px; width: 250px; display: none;"></audio>
                </div>

                <div style="display: flex; gap: 10px; margin-top: 20px;">
                    <textarea id="chatInput" placeholder="Type a message to Gemini..." style="flex: 1; min-height: 60px; background: #0a0a0a; color: #ddd; border: 1px solid #333; padding: 10px; resize: none; border-radius: 5px; font-family: monospace;"></textarea>
                    <button id="sendChatBtn" style="padding: 0 20px; cursor: pointer; background: #004400; color: #fff; border: none; border-radius: 4px; font-weight: bold;">SEND</button>
                    <button id="sendContextBtn" style="padding: 0 20px; cursor: pointer; background: #fdf902; color: #020202; border: none; border-radius: 4px; font-weight: bold;">CONTEXT</button>
                </div>
            </div>

            <!-- RIGHT COLUMN: Video & Controls -->
            <div style="flex: 1; display: flex; flex-direction: column; align-items: center; gap: 5px; height: 100%; overflow-y: auto;">
                
                <!-- Frame border controlled by JS via class/style -->
                
                

                <div id="status" style="color: #888; font-weight: bold;">System Status: Idle</div>

                <div style="width: 90%; text-align: left; flex: 1; display: flex; flex-direction: column;">
                    <div style="width: 100%; flex: 1; min-height: 150px; background: #000; border: 1px solid #333; padding: 10px; font-family: monospace; font-size: 14px; margin-top: 5px; border-radius: 5px; overflow-y: auto;">
                        <ul id="geminiLogList" style="list-style: none; padding: 0; margin: 0;"></ul>
                    </div>
                </div>
            </div>

        </div>

        <script>
            const startBtn = document.getElementById('startAudioBtn');
            const useGeminiCk = document.getElementById('useGeminiCk');
            const muteMicCk = document.getElementById('muteMicCk');
            const operatorMode = document.getElementById('operatorMode');
            const statusDiv = document.getElementById('status');
            const videoImg = document.getElementById('videoStream');
            const videoContainer = document.getElementById('videoContainer');
            const geminiLogList = document.getElementById('geminiLogList');
            const instructionArea = document.getElementById('instructionArea');
            const behaviourArea = document.getElementById('behaviourArea');
            const saveBehBtn = document.getElementById('saveBehBtn');
            const muteMicContainer = document.getElementById('muteMicContainer');
            const operatorSoundContainer = document.getElementById('operatorSoundContainer');
            const soxInput = document.getElementById('soxParamsInput');
            const testSoxBtn = document.getElementById('testSoxBtn');
            const testAudioPlayer = document.getElementById('testAudioPlayer');

            // --- SETTINGS FETCH ---
            fetch('/settings').then(r => r.json()).then(s => {
                if (s.ENABLE_CLIENT_MIC_MONITORING) {
                    muteMicContainer.style.display = 'flex';
                    operatorSoundContainer.style.display = 'flex';
                }
                // Pre-fill SoX params if available, unless user edited
                // if(s.SOX_PARAMS) soxInput.value = s.SOX_PARAMS; 
            }).catch(e => console.log("Settings fetch error", e));

            // --- SOX TESTER ---
            testSoxBtn.onclick = async () => {
                const params = encodeURIComponent(soxInput.value);
                const url = `/test-sox?settings=${params}&t=${Date.now()}`; // timestamp to prevent caching
                
                testSoxBtn.disabled = true;
                testSoxBtn.innerText = "GENERATING...";
                testAudioPlayer.style.display = 'none';
                testAudioPlayer.pause();

                try {
                    // Fetch as blob to ensure valid audio before playing
                    const res = await fetch(url);
                    if (!res.ok) throw new Error(await res.text());
                    
                    const blob = await res.blob();
                    const audioUrl = URL.createObjectURL(blob);
                    
                    testAudioPlayer.src = audioUrl;
                    testAudioPlayer.style.display = 'block';
                    testAudioPlayer.play();
                } catch(e) {
                    alert("Error generating audio: " + e.message);
                } finally {
                    testSoxBtn.disabled = false;
                    testSoxBtn.innerText = "TEST AUDIO";
                }
            };

            // --- INSTRUCTION MANAGER ---
            async function loadInstruction() {
                try {
                    const res = await fetch('/instruction');
                    const text = await res.text();
                    console.log(text);
                    //instructionArea.value = text;
                } catch(e) { console.error("Failed to load instruction", e); }
            }
            loadInstruction();

            /*saveInstrBtn.onclick = async () => {
                const text = instructionArea.value;
                try {
                    const res = await fetch('/instruction', {
                        method: 'POST',
                        headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify({ text })
                    });
                    if (res.ok) {
                        console.log("Saved! Please toggle 'Use Gemini AI' off and on to apply changes.");
                    } else {
                        alert("Error saving.");
                    }
                } catch(e) { alert("Error: " + e.message); }
            };*/

            // --- INSTRUCTION MANAGER ---
            async function loadBehaviour() {
                try {
                    const res = await fetch('/behaivior');
                    const text = await res.text();
                    behaviourArea.value = text;
                } catch(e) { console.error("Failed to load behaivior", e); }
            }
            loadBehaviour();

            saveBehBtn.onclick = async () => {
                const text = behaviourArea.value;
                try {
                    const res = await fetch('/behaivior', {
                        method: 'POST',
                        headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify({ text })
                    });
                    if (res.ok) {
                        console.log("Saved! Please toggle 'Use Gemini AI' off and on to apply changes.");
                    } else {
                        alert("Error saving.");
                    }
                } catch(e) { alert("Error: " + e.message); }
            };

            let audioCtx;
            let videoSocket;
            let audioSocket;
            let geminiControlSocket;
            let nextTime = 0;

            function log(msg) {
                const li = document.createElement('li');
                li.style.borderBottom = '1px solid #222';
                li.style.padding = '4px 0';
                li.style.color = '#ccc'; // default
                
                // Content parsing for color
                if(msg.startsWith("THINK:")) li.style.color = '#0af';     // Blue
                else if(msg.startsWith("WHISPER:")) li.style.color = '#8f8'; // Light Green
                else if(msg.startsWith("AI:")) li.style.color = '#0f0'; // Matrix Green
                else if(msg.startsWith("User:")) li.style.color = '#0ff'; // Cyan
                else if(msg.indexOf("Error") !== -1) li.style.color = '#f00'; // Red
                else if(msg.indexOf("Session") !== -1) li.style.color = '#ff0'; // Yellow

                li.innerText = `[${new Date().toLocaleTimeString()}] ${msg}`;
                geminiLogList.prepend(li); // Add to top
            }

            // --- GEMINI CONTROL ---
            const sendChatBtn = document.getElementById('sendChatBtn');
            const sendContextBtn = document.getElementById('sendContextBtn');

            const sendAudioCk = document.getElementById('sendAudioCk');

            function toggleGemini(enabled) {
                if (!geminiControlSocket || geminiControlSocket.readyState !== WebSocket.OPEN) return;
                
                geminiControlSocket.send(JSON.stringify({ 
                    type: 'gemini_control', 
                    enabled: enabled 
                }));
                // Update Audio Send State based on both toggles
                updateGeminiAudioState();

                if (enabled) {
                    videoContainer.style.borderColor = "#f00"; // Red Frame
                    log("Gemini Session REQUESTED...");
                } else {
                    videoContainer.style.borderColor = "#444"; // Grey Frame
                    log("Gemini Session ENDED.");
                }
            }

            function updateGeminiAudioState() {
                if (!geminiControlSocket || geminiControlSocket.readyState !== WebSocket.OPEN) return;
                
                 geminiControlSocket.send(JSON.stringify({ 
                    type: 'audio_control', 
                    enabled: sendAudioCk.checked && useGeminiCk.checked
                }));
            }

            useGeminiCk.addEventListener('change', (e) => {
                toggleGemini(e.target.checked);
            });
            sendAudioCk.addEventListener('change', (e) => {
                updateGeminiAudioState();
            });
            operatorMode.addEventListener('change', (e) => {
                if (geminiControlSocket && geminiControlSocket.readyState === WebSocket.OPEN) {
                     geminiControlSocket.send(JSON.stringify({
                         type: 'gemini_chat',
                         text: e.target.checked?"[OWNER_START]":"[OWNER_STOP]"
                     }));
                } else {
                    log("Error: Control socket not connected. Start monitor first.");
                }
            });

            // --- CHAT SEND ---
            sendChatBtn.onclick = () => {
                const text = document.getElementById('chatInput').value;
                if(!text) return;
                
                if (geminiControlSocket && geminiControlSocket.readyState === WebSocket.OPEN) {
                     log("User: " + text);
                     geminiControlSocket.send(JSON.stringify({
                         type: 'gemini_chat',
                         text: text
                     }));
                     document.getElementById('chatInput').value = '';
                } else {
                    log("Error: Control socket not connected. Start monitor first.");
                }
            };
            sendContextBtn.onclick = () => {
                if (geminiControlSocket && geminiControlSocket.readyState === WebSocket.OPEN) {
                     geminiControlSocket.send(JSON.stringify({
                         type: 'gemini_chat',
                         text: "[CONTEXT]"
                     }));
                } else {
                    log("Error: Control socket not connected. Start monitor first.");
                }
            };
            // -----------------

            // --- MONITOR SETUP ---
            function setupControlSocket() {
                const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                geminiControlSocket = new WebSocket(protocol + '//' + window.location.host + '/control');
                
                geminiControlSocket.onopen = () => console.log("Control WS Connected");
                geminiControlSocket.onmessage = (event) => {
                    const msg = JSON.parse(event.data);
                    
                    if (msg.type === 'gemini_command') {
                        const cmd = msg.command; // SAY, THINK, etc.
                        const text = msg.text;

                        if (cmd === 'EMOTION') {
                            const emoDiv = document.getElementById('emotionDisplay');
                            const e = text.toLowerCase();
                            let icon = '';
                            let color = '#fff';
                            
                            if (e.includes('joy') || e.includes('happ')) { icon = 'ðŸ˜Š'; color = '#0f0'; }
                            else if (e.includes('anger') || e.includes('angry')) { icon = 'ðŸ˜¡'; color = '#f00'; }
                            else if (e.includes('sad')) { icon = 'ðŸ˜¢'; color = '#00f'; }
                            else if (e.includes('surprise')) { icon = 'ðŸ˜²'; color = '#ff0'; }
                            else if (e.includes('fear')) { icon = 'ðŸ˜±'; color = '#f0f'; }
                            else if (e.includes('process')) { icon = 'ðŸ”„'; color = '#aaa'; }
                            
                            emoDiv.innerText = icon ? icon + " " + text.toUpperCase() : '';
                            emoDiv.style.color = color;
                        } else {
                            // Map command to log prefix/logic
                            let logPrefix = `${cmd}: `;
                            if(cmd === 'SAY') logPrefix = "AI: ";
                            log(logPrefix + text);
                        }
                    }

                    if (msg.type === 'log') {
                        // System logs from server
                        // log("SYS: " + msg.text); 
                    }
                };
            }

            startBtn.onclick = async () => {
                startBtn.disabled = true;
                startBtn.innerText = "Connecting...";
                
                try {
                    // 1. Audio Context
                    audioCtx = new (window.AudioContext || window.webkitAudioContext)({
                        sampleRate: 16000, 
                        latencyHint: 'interactive'
                    });
                    await audioCtx.resume();

                    // 2. Control Socket
                    setupControlSocket();

                    // 3. Video Monitor
                    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                    videoSocket = new WebSocket(protocol + '//' + window.location.host + '/monitor/video');
                    videoSocket.binaryType = 'arraybuffer';
                    videoSocket.onmessage = (event) => {
                        const blob = new Blob([event.data], { type: 'image/jpeg' });
                        const url = URL.createObjectURL(blob);
                        videoImg.onload = () => URL.revokeObjectURL(url);
                        videoImg.src = url;
                    };

                    // 4. Audio Monitor (Expects Int16 now, need to fix playing)
                    // If server disabled mic monitoring, this socket will close immediately.
                    fetch('/settings').then(r=>r.json()).then(settings => {
                        if (!settings.ENABLE_CLIENT_MIC_MONITORING) return;
                        
                        audioSocket = new WebSocket(protocol + '//' + window.location.host + '/monitor/audio');
                        audioSocket.binaryType = 'arraybuffer';
                        
                        audioSocket.onmessage = (event) => {
                            if (muteMicCk.checked) return;

                            if (audioCtx.state === 'suspended') audioCtx.resume();
                            
                            const rawData = new Int16Array(event.data); 
                            const floatArray = new Float32Array(rawData.length);
                            for(let i=0; i<rawData.length; i++) floatArray[i] = rawData[i] / 32768.0;

                            const buffer = audioCtx.createBuffer(1, floatArray.length, 16000);
                            buffer.copyToChannel(floatArray, 0);
                            
                            const source = audioCtx.createBufferSource();
                            source.buffer = buffer;
                            source.connect(audioCtx.destination);
                            
                            if (nextTime < audioCtx.currentTime) nextTime = audioCtx.currentTime;
                            source.start(nextTime);
                            nextTime += buffer.duration;
                        };
                    });

                    // 5. TTS Monitor (Voice Response) - Mixes with Mic
                    const ttsSocket = new WebSocket(protocol + '//' + window.location.host + '/monitor/tts');
                    ttsSocket.binaryType = 'arraybuffer';
                    ttsSocket.onmessage = (event) => {
                        if (audioCtx.state === 'suspended') audioCtx.resume();
                        
                        // WAV file header is 44 bytes. Simple skip or decode?
                        // decodeAudioData is async and handles full WAV files perfectly.
                        // Since Piper sends full WAV files as blobs.
                        audioCtx.decodeAudioData(event.data, (buffer) => {
                            const source = audioCtx.createBufferSource();
                            source.buffer = buffer;
                            source.connect(audioCtx.destination);
                            source.start(0); // Play immediately mixed
                            //log("Playing TTS Audio...");
                        }, (err) => console.error("Error decoding TTS audio", err));
                    };

                    statusDiv.innerText = "System Active. Ready to use Gemini.";
                    statusDiv.style.color = "#0f0";
                    startBtn.style.display = 'none';

                } catch (err) {
                    console.error(err);
                    statusDiv.innerText = "Error: " + err.message;
                    startBtn.disabled = false;
                }
            };

            // KEYBOARD INPUT FORWARDING
            document.addEventListener('keydown', (e) => {
                // Ignore if typing in text inputs (chat, behavior, etc.)
                if (e.target.tagName === 'TEXTAREA' || e.target.tagName === 'INPUT') return;

                if (!geminiControlSocket || geminiControlSocket.readyState !== WebSocket.OPEN) return;
                
                if (e.repeat) return; 

                const validKeys = [' ', 'Enter', '1', '2', '3', '4'];
                if (validKeys.includes(e.key)) {
                    if(e.key === ' ') e.preventDefault(); 
                    console.log("Key sent: " + e.key);
                    geminiControlSocket.send(JSON.stringify({
                        type: 'keyboard_event',
                        data: { key: e.key, action: 'press' }
                    }));
                }
            });

            document.addEventListener('keyup', (e) => {
                 // Ignore if typing in text inputs
                if (e.target.tagName === 'TEXTAREA' || e.target.tagName === 'INPUT') return;

                if (!geminiControlSocket || geminiControlSocket.readyState !== WebSocket.OPEN) return;

                const validKeys = [' ', 'Enter', '1', '2', '3', '4'];
                if (validKeys.includes(e.key)) {
                    if(e.key === ' ') e.preventDefault();
                    
                    geminiControlSocket.send(JSON.stringify({
                        type: 'keyboard_event',
                        data: { key: e.key, action: 'release' }
                    }));
                }
            });
        </script>
    </body>
</html>